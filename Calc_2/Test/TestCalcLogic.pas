unit TestCalcLogic;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

{$RTTI EXPLICIT METHODS([vcPrivate..vcPublished]) PROPERTIES([vcPrivate..vcPublished]) FIELDS([vcPrivate..vcPublished])}

uses
  System.SysUtils, System.Classes, Variants, TestFramework, CalcLogic, DUnitTestingCore, TestStructureUnit, RTTI;

type
  // Test methods for class TCalcLogic

  TestTCalcLogic = class(TCoreTestCase)
  strict private
    TestCalcLogic: TCalcLogic;
  private
    a, b: variant;
    ExpectedResult: variant;
    FailMessage: string;
    Operation: string;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAdd;
    procedure TestSub;
  end;

  TestTCalcLogic1 = class(TCoreTestCase)
  strict private
    TestCalcLogic1: TCalcLogic;
  private
    a, b: integer;
    ExpectedResult: integer;
    FailMessage: string;
    Operation: string;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestMul;
    procedure TestDiv;
  end;

implementation

procedure TestTCalcLogic.SetUp;
var
  ParamValue: TInputDataArray;
begin
  TestCalcLogic := TCalcLogic.Create;
  ParamValue := DataArray.Items[Self.FTestName];
  a := ParamValue[0].AsVariant;
  b := ParamValue[1].AsVariant;
  ExpectedResult := ParamValue[2].AsVariant;
  FailMessage := ParamValue[3].AsString;
  Operation := ParamValue[4].AsString;
end;


procedure TestTCalcLogic.TearDown;
begin
  TestCalcLogic.Free;
  TestCalcLogic := nil;
end;


procedure TestTCalcLogic.TestAdd;
var
  ReturnValue: Integer;
begin
  if Operation = 'except' then
  begin
    StartExpectingException(Exception);
    ReturnValue := TestCalcLogic.Add(a, b);
    StopExpectingException('');
  end
  else
    ReturnValue := TestCalcLogic.Add(a, b);
  AssertResults<integer>(ExpectedResult, ReturnValue, Operation, FailMessage);
end;


procedure TestTCalcLogic.TestSub;
var
  ReturnValue: Integer;
begin
  StartExpectingException(Exception);
  ReturnValue := TestCalcLogic.Sub(a, b);
  StopExpectingException('');
  AssertResults<integer>(ExpectedResult, ReturnValue, Operation, FailMessage);
end;


procedure TestTCalcLogic1.SetUp;
var
  ParamValue: TInputDataArray;
begin
  TestCalcLogic1 := TCalcLogic.Create;
  ParamValue := DataArray.Items[Self.FTestName];
  a := ParamValue[0].AsVariant;
  b := ParamValue[1].AsVariant;
  ExpectedResult := ParamValue[2].AsVariant;
  FailMessage := ParamValue[3].AsVariant;
  Operation := ParamValue[4].AsVariant;
end;


procedure TestTCalcLogic1.TearDown;
begin
  TestCalcLogic1.Free;
  TestCalcLogic1 := nil;
end;


procedure TestTCalcLogic1.TestMul;
var
  ReturnValue: Integer;
begin
  StartExpectingException(Exception);
  ReturnValue := TestCalcLogic1.Mul(a, b);
  StopExpectingException('');
  AssertResults<integer>(ExpectedResult, ReturnValue, Operation, FailMessage);
end;


procedure TestTCalcLogic1.TestDiv;
var
  ReturnValue: Integer;
begin
  if Operation = 'except' then
  begin
    StartExpectingException(Exception);
    ReturnValue := TestCalcLogic1.Division(a, b);
    StopExpectingException('');
    AssertResults<integer>(ExpectedResult, ReturnValue, Operation, FailMessage);
  end
  else
    try
      ReturnValue := TestCalcLogic1.Division(a, b);
      AssertResults<integer>(ExpectedResult, ReturnValue, Operation, FailMessage);
    except
      Fail('Actual result is exception! Expected result = ' + VarToStr(ExpectedResult));
    end;
end;

initialization
end.

